"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.staticCard = void 0;
const core_1 = require("@discord-card/core");
const canvas_1 = require("canvas");
const promises_1 = require("fs/promises");
const lib_1 = require("../lib");
const dryMap = {};
function staticCard(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    var _z, _0;
    return __awaiter(this, void 0, void 0, function* () {
        //check for existing
        if (((_a = options.generation) === null || _a === void 0 ? void 0 : _a.static) && dryMap[(_b = options.generation) === null || _b === void 0 ? void 0 : _b.static]) {
            return dryMap[options.generation.static];
        }
        //const timer = new Timer('Prepare').start();
        const timer = {
            step: (...args) => { },
            stop: (...args) => { },
        };
        const w = 700, h = 250;
        let canvas = (0, canvas_1.createCanvas)(w, h);
        const ctx = canvas.getContext('2d');
        timer.step('created Canvas');
        //@ts-ignore
        let theme;
        let background;
        (_c = options.card) !== null && _c !== void 0 ? _c : (options.card = {});
        (_d = (_z = options.card).border) !== null && _d !== void 0 ? _d : (_z.border = true);
        (_e = (_0 = options.card).rounded) !== null && _e !== void 0 ? _e : (_0.rounded = true);
        //Parsing the Theme
        if (typeof ((_f = options.theme) !== null && _f !== void 0 ? _f : 'code') === 'string') {
            theme = lib_1.themes[(_g = options.theme) !== null && _g !== void 0 ? _g : 'code'];
            if (!theme)
                throw new Error('Invalid theme, use: ' + Object.keys(lib_1.themes).join(' | '));
            background = yield (0, core_1.toImage)(yield (0, promises_1.readFile)(theme.image));
        }
        else
            throw new Error('Invalid theme, use: ' + Object.keys(lib_1.themes).join(' | '));
        if (options.card.background)
            background = yield (0, core_1.toImage)(options.card.background, 'Background');
        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
        let backgroundScale = h / background.height;
        if (w / background.width > backgroundScale) {
            backgroundScale = w / background.width;
        }
        //console.log(backgroundScale);
        let backXOff = (background.width - backgroundScale * background.width) / 2, backYOff = (background.height - backgroundScale * background.height) / 2;
        //console.log(backXOff, backYOff);
        timer.step('loaded Background');
        /** Border width */
        const b = 10; //Border
        //Background
        (0, lib_1.snap)(canvas);
        if ((_h = options.card) === null || _h === void 0 ? void 0 : _h.rounded) {
            (0, core_1.roundRect)(ctx, 0, 0, w, h, h / 15);
            ctx.clip();
        }
        if ((_j = options.card) === null || _j === void 0 ? void 0 : _j.border) {
            ctx.drawImage(background, backXOff, backYOff, w, h, 0, 0, w, h);
            //ctx.drawImage(background, 0, 0, w, h);
            //darken the borders
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.globalAlpha = 1;
            //StackBlur.canvasRGBA(ctx.canvas as any, 0, 0, w, h, 9);
            canvas = (0, core_1.blur)(canvas, 3);
            if ((_k = options.card) === null || _k === void 0 ? void 0 : _k.rounded) {
                (0, core_1.roundRect)(ctx, b, b, w - 2 * b, h - 2 * b, h / 20);
            }
            else {
                ctx.rect(b, b, w - 2 * b, h - 2 * b);
            }
            ctx.clip();
        }
        timer.step('border');
        var temp = background;
        if ((_l = options.card) === null || _l === void 0 ? void 0 : _l.blur) {
            var blurred = (0, canvas_1.createCanvas)(w, h), blur_ctx = blurred.getContext('2d');
            blur_ctx.drawImage(background, backXOff, backYOff, w, h, 0, 0, w, h);
            //blur_ctx.drawImage(background, 0, 0, w, h);
            if (typeof ((_m = options.card) === null || _m === void 0 ? void 0 : _m.blur) === 'boolean')
                options.card.blur = 3;
            blurred = (0, core_1.blur)(blurred, (_o = options.card) === null || _o === void 0 ? void 0 : _o.blur);
            //StackBlur.canvasRGBA(blurred as any, 0, 0, blurred.width, blurred.height, options.blur * 3);
            temp = blurred;
        }
        if ((_p = options.card) === null || _p === void 0 ? void 0 : _p.border)
            ctx.drawImage(temp, b, b, w - b * 2, h - b * 2);
        else
            ctx.drawImage(background, backXOff, backYOff, w, h, 0, 0, w, h);
        timer.step('blur');
        (0, lib_1.snap)(canvas);
        //Setting Styles
        ctx.fillStyle = ((_r = (_q = options.text) === null || _q === void 0 ? void 0 : _q.color) !== null && _r !== void 0 ? _r : theme.color).toString(ctx);
        //ctx.strokeStyle = theme.color.toString(ctx);
        ctx.font = '30px ' + ((_u = (_t = (_s = options.text) === null || _s === void 0 ? void 0 : _s.font) !== null && _t !== void 0 ? _t : theme.font) !== null && _u !== void 0 ? _u : 'SegoeUI') + ', SegoeUI, SegoeUIEmoji';
        timer.step('text');
        //Avatar Image
        const radius = (h / 2) * ((_w = (_v = options.avatar) === null || _v === void 0 ? void 0 : _v.imageRadius) !== null && _w !== void 0 ? _w : 0.8);
        function applyShape(offset = 0) {
            var _a;
            if ((_a = options.avatar) === null || _a === void 0 ? void 0 : _a.borderRadius) {
                (0, core_1.roundRect)(ctx, h / 2 - radius - offset, h / 2 - radius - offset, radius * 2 + 2 * offset, radius * 2 + 2 * offset, options.avatar.borderRadius * radius);
            }
            else {
                ctx.beginPath();
                ctx.arc(h / 2, h / 2, radius + offset, 0, Math.PI * 2, true);
                ctx.closePath();
            }
            return ctx;
        }
        const { avatar } = options;
        if (avatar) {
            const { outlineWidth, outlineColor } = avatar;
            if (outlineWidth) {
                applyShape(-outlineWidth);
                let r = radius;
                ctx.lineWidth = outlineWidth * 1.5;
                ctx.strokeStyle = ((_x = outlineColor !== null && outlineColor !== void 0 ? outlineColor : theme.color) !== null && _x !== void 0 ? _x : '#fff').toString(ctx, h / 2 - r, h / 2 - r, h / 2 + r, h / 2 + r);
                ctx.stroke();
            }
        }
        timer.step('avatar');
        timer.stop();
        if ((_y = options.generation) === null || _y === void 0 ? void 0 : _y.static) {
            dryMap[options.generation.static] = canvas;
        }
        return canvas;
    });
}
exports.staticCard = staticCard;
//# sourceMappingURL=dry.js.map